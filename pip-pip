#!/usr/bin/env python
## -*- mode:python -*-
# $PIP_VERSION: Version 2.0.0$
# $PIP_license: <Simplified BSD License>
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# The views and conclusions contained in the software and documentation
# are those of the authors and should not be interpreted as representing
# official policies, either expressed or implied, of the PiP project.$
# $RIKEN_copyright: Riken Center for Computational Sceience,
# System Software Development Team, 2016, 2017, 2018, 2019, 2020$

from __future__ import print_function
import datetime
import time
import argparse
import shutil
import os
import sys
import subprocess as sp
import re

# Ready list: (how, arch, redhat, pip )
ready = { ( 'yum',      'x86_64',  7, 1 ): True,
          ( 'yum',      'x86_64',  7, 2 ): False,
          ( 'yum',      'x86_64',  7, 3 ): False,
          ( 'yum',      'x86_64',  8, 1 ): False,
          ( 'yum',      'x86_64',  8, 2 ): False,
          ( 'yum',      'x86_64',  8, 3 ): False,
          ( 'yum',      'aarch64', 7, 1 ): False,
          ( 'yum',      'aarch64', 7, 2 ): False,
          ( 'yum',      'aarch64', 7, 3 ): False,
          ( 'yum',      'aarch64', 8, 1 ): False,
          ( 'yum',      'aarch64', 8, 2 ): False,
          ( 'yum',      'aarch64', 8, 3 ): False,

          ( 'docker',   'x86_64',  7, 1 ): True,
          ( 'docker',   'x86_64',  7, 2 ): False,
          ( 'docker',   'x86_64',  7, 3 ): False,
          ( 'docker',   'x86_64',  8, 1 ): False,
          ( 'docker',   'x86_64',  8, 2 ): False,
          ( 'docker',   'x86_64',  8, 3 ): False,
          ( 'docker',   'aarch64', 7, 1 ): False,
          ( 'docker',   'aarch64', 7, 2 ): False,
          ( 'docker',   'aarch64', 7, 3 ): False,
          ( 'docker',   'aarch64', 8, 1 ): False,
          ( 'docker',   'aarch64', 8, 2 ): False,
          ( 'docker',   'aarch64', 8, 3 ): False,

          ( 'spack',    'x86_64',  7, 1 ): True,
          ( 'spack',    'x86_64',  7, 2 ): False,
          ( 'spack',    'x86_64',  7, 3 ): False,
          ( 'spack',    'x86_64',  8, 1 ): False,
          ( 'spack',    'x86_64',  8, 2 ): False,
          ( 'spack',    'x86_64',  8, 3 ): False,
          ( 'spack',    'aarch64', 7, 1 ): False,
          ( 'spack',    'aarch64', 7, 2 ): False,
          ( 'spack',    'aarch64', 7, 3 ): False,
          ( 'spack',    'aarch64', 8, 1 ): False,
          ( 'spack',    'aarch64', 8, 2 ): False,
          ( 'spack',    'aarch64', 8, 3 ): False,

          ( 'github',   'x86_64',  7, 1 ): True,
          ( 'github',   'x86_64',  7, 2 ): True,
          ( 'github',   'x86_64',  7, 3 ): True,
          ( 'github',   'x86_64',  8, 1 ): False,
          ( 'github',   'x86_64',  8, 2 ): True,
          ( 'github',   'x86_64',  8, 3 ): True,
          ( 'github',   'aarch64', 7, 1 ): True,
          ( 'github',   'aarch64', 7, 2 ): True,
          ( 'github',   'aarch64', 7, 3 ): True,
          ( 'github',   'aarch64', 8, 1 ): False,
          ( 'github',   'aarch64', 8, 2 ): True,
          ( 'github',   'aarch64', 8, 3 ): True,

          ( 'git-rccs', 'x86_64',  7, 1 ): True,
          ( 'git-rccs', 'x86_64',  7, 2 ): True,
          ( 'git-rccs', 'x86_64',  7, 3 ): True,
          ( 'git-rccs', 'x86_64',  8, 1 ): False,
          ( 'git-rccs', 'x86_64',  8, 2 ): True,
          ( 'git-rccs', 'x86_64',  8, 3 ): True,
          ( 'git-rccs', 'aarch64', 7, 1 ): True,
          ( 'git-rccs', 'aarch64', 7, 2 ): True,
          ( 'git-rccs', 'aarch64', 7, 3 ): True,
          ( 'git-rccs', 'aarch64', 8, 1 ): False,
          ( 'git-rccs', 'aarch64', 8, 2 ): True,
          ( 'git-rccs', 'aarch64', 8, 3 ): True
}

msg_enter   = '>>>'
msg_exit    = '<<<'
msg_error   = '<<E'
msg_prefix  ='---'
msg_prefix1 ='###'
err_prefix  ='ERROR:'
warn_prefix ='WARNING:'
sep = '\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n'

sudo_cmd       = []
prompt_prefix  = False
prompt_rm_work = False
flag_multi     = False
dryrun         = False
spack_path     = None

null_file = open(os.devnull,'w')
git_clone = [ 'git', 'clone' ]

def redhat_version():
    ver = None
    try:
        with open( '/etc/redhat-release', mode='r' ) as f:
            rhel = f.readline().split()
            while True:
                if rhel == []:
                    raise Exception( 'Unknown readhat-release content' )
                token = rhel.pop( 0 )
                if token == 'release':
                    verstr = rhel.pop( 0 )
                    ver = int( verstr.split( '.' ).pop( 0 ) )
                    break;
        return ver
    except Exception as e:
        print( err_prefix, e )
        flag_error = True
        return None

def cpu_arch():
    return sp.check_output( [ 'uname', '-m' ] ).decode().split().pop(0)

def log( list, log_fs, newline ):
    last = list[-1]
    for msg in list:
        if msg != last:
            if not args.quiet:
                print( msg, end=' ' )
            if not dryrun:
                print( msg, end=' ', file=log_fs )
        else:
            if newline:
                if not args.quiet:
                    print( msg )
                    sys.stdout.flush()
                if not dryrun:
                    print( msg, file=log_fs )
                    log_fs.flush()
            else:
                if not args.quiet:
                    print( msg, end='' )
                    sys.stdout.flush()
                if not dryrun:
                    print( msg, end='', file=log_fs )
                    log_fs.flush()

def is_privileged( log_fs ):
    global error

    if os.environ['USER'] == 'root':
        return True

    sudo_cmd = [ 'sudo', '/bin/sh', '-c' ]

    able_to_sudo = False
    sudo_rc = sp.call( [ '/bin/sh',
                         '-c',
                         'sudo -S true < /dev/null > /dev/null 2>&1' ] )
    if sudo_rc == 0:
        able_to_sudo = True
    if args.sudo:
        if able_to_sudo:
            return True
        else:
            log( [ err_prefix, "Unable to 'sudo'" ], log_fs, True )
    else:
        if able_to_sudo:
            log( [ err_prefix, '--sudo option is required to sudo' ],
                 log_fs, True )
        else:
            log( [ err_prefix, 'user is not sudo-able' ], log_fs, True )
    error = True
    return False

cmd = sys.argv[0]

parser = argparse.ArgumentParser( description='pip-pip: Process-in-Process package installing program',
                                  add_help = True )
parser.add_argument( '--how', '-H',
                     help    = 'Specifying how to install [yum|docker|spack|GITHUB]',
                     type    = str,
                     action  = 'append' )
parser.add_argument( '--version', '-v',
                     help    = "Specifying PiP version (2 or 3. default '2')",
                     type    = str,
                     action  = 'append' )
parser.add_argument( '--prefix', '-p',
                     help    = "Install directory ([spack,] github. default 'install')",
                     type    = str,
                     default = 'install',
                     nargs   = '?' )
parser.add_argument( '--work', '-w',
                     help    = "Working directory (default 'work')",
                     type    = str,
                     default = 'work',
                     nargs   = '?' )
parser.add_argument( '--keep', '-k',
                     help    = 'Keep working directory.  Work is deleted when succeeded by default',
                     action  = 'store_true' )
parser.add_argument( '--sudo', '-s',
                     help    = 'allow sudo (yum, docker)',
                     action  = 'store_true' )
parser.add_argument( '--dryrun', '-D',
                     help    = 'dry run',
                     action  = 'store_true' )
parser.add_argument( '--force', '-f',
                     help    = 'do not ask user',
                     action  = 'store_true' )
parser.add_argument( '--quiet', '-q',
                     help    = 'quiet mode',
                     action  = 'store_true' )
parser.add_argument( '--noglibc', '-noglibc',
                     help    = 'Do not build PiP-glibc and PiP_gdb (github)',
                     action  = 'store_true' )
parser.add_argument( '--nogdb', '-nogdb',
                     help    = 'Do not build PiP_gdb (github)',
                     action  = 'store_true' )
parser.add_argument( '--test', '-t',
                    type     = int, 
                    nargs    = '?',
                    default  = 10,
                    help     = 'The threshold of the number of PiP testsuite errors (10)' )
args = parser.parse_args()

test_threshold = args.test
if test_threshold < 0: 
    test_threshold = 10
os.environ['PIP_TEST_THRESHOLD'] = str(test_threshold)

dryrun = args.dryrun

def expand( list, flag_lower ):
    if list == []:
        return []

    if flag_lower:
        token = list.pop( 0 ).lower()
    else:
        token = list.pop( 0 )

    if ',' in token:
        return token.split( ',' ) + expand( list, flag_lower )
    elif '+' in token:
        return token.split( '+' ) + expand( list, flag_lower )
    return [ token ] + expand( list, flag_lower )

## check how
how_list = set( expand( args.how, True ) )
how_all = [ 'yum', 'docker', 'spack', 'github' ]
how_ALL = how_all + [ 'git-rccs' ]

if 'all' in how_list:
    how_list = how_all
elif 'ALL' in how_list:
    how_list = how_ALL
elif how_list == []:
    how_list = [ 'github' ]
else:
    errlist = []
    howlist = []
    for h in how_list:
        if h in how_ALL:
            howlist.append( h )
        else:
            errlist.append( h )
    if errlist != []:
        print( err_prefix, errlist, 'is(are) not acceptable value(s) of --how' )
        parser.print_help()
        error = True
    if howlist == []:
        error = True
    how_list = howlist
if len( how_list ) > 1:
    flag_multi = True

def check_command( command ):
    if shutil.which( command  ) == None:
        return False
    return True

no_spack = False
error = False
for h in how_list:
    if h is 'yum':
        if not check_command( 'yum' ):
            print( err_prefix, 'Unable to find YUM command' )
            error = True
    if h is 'docker':
        if not check_command( 'docker' ):
            print( err_prefix, 'Unable to find DOCKER command' )
            error = True
    if h is 'spack':
        if not check_command( 'spack' ):
            no_spack = True;
            if not check_command( 'git' ):
                print( err_prefix,
                       'Unable to find GIT command (required to install Spack)' )
                error = True
    if h is 'github' or h is 'git-rccs':
        if not check_command( 'git' ):
            print( err_prefix, 'Unable to find GIT command' )
            error = True

## check Linux distribution and version
redhat_ver = redhat_version()
if redhat_ver != None:
    if redhat_ver != 7 and redhat_ver != 8:
        print( err_prefix, 'RHEL', redhat_ver, 'is not supported' )
        error = True

## Check PiP version
version = sorted( set( expand( args.version, False ) ) )
pip_vers = []
if 'ALL' in version:
    if redhat_ver == 7:
        pip_vers = [ 1, 2, 3 ]
    else:
        pip_vers = [ 2, 3 ]
elif 'all' in version:
    pip_vers = [ 2, 3 ]
elif version == []:
    pip_vers = [ 2 ]
else:
    ver_acceptable = [ -1, 2, 3 ]
    errlist     = []
    for ver_str in version:
        ver = int( ver_str )
        if ver in ver_acceptable:
            pip_vers.append( abs( ver ) )
        else:
            errlist.append( ver )
    errlen = len( errlist )
    if errlen > 0:
        if errlen == 1:
            print( err_prefix, errlist.pop(0), 'is not an acceptable value of --version' )
        else:
            print( err_prefix, errlist, 'are not acceptable values of --version' )
        error = True
if len( pip_vers ) > 1:
    flag_multi = True

# check arch
arch = cpu_arch()
if arch != 'x86_64' and arch != 'aarch64':
    print( err_prefix, arch, 'is not supported by PiP' )

def make_directory( path, flag ):
    if not dryrun:
        try:
            if os.path.isdir( path ):
                if flag:
                    return path
                else:
                    print( err_prefix, 'Dirctory (' + path + ') already exists' )
                    flag_error = True
                    return None
            os.mkdir( path )
            return path
        except Exception as e:
            print( err_prefix, e )
            flag_error = True
            return None
    else:
        return dir

# check and create prefix dir
def check_prefix( prefix ):
    global prompt_prefix

    prefix = os.path.realpath( os.path.expanduser( prefix ) )
    if dryrun:
        return prefix
    elif os.path.isfile( prefix ):
        print( err_prefix, prefix, 'is not a directory but a file' )
        error = True
        return None
    elif os.path.isdir( prefix ):
        if not args.force and not prompt_prefix:
            print( warn_prefix, 'Prefix directory already exists: ', prefix )
            while True:
                try:
                    prompt = "Are you sure to install in prefix directory? 'yes' or 'no' [y/N]: "
                    choice = input( prompt ).lower()
                except:
                    print( '' )
                    sys.exit( 1 )

                if choice in [ 'y', 'ye', 'yes' ]:
                    prompt_prefix = True
                    break
                elif choice in [ 'n', 'no' ]:
                    sys.exit( 1 )
    return prefix

def prefix_path( prefix, how, ver ):
    global flag_multi
    if not flag_multi:
        return prefix
    else:
        return os.path.join( prefix,
                             arch + '_' +
                             'redhat-' + str( redhat_ver ) + '_' +
                             how + '_' +
                             'pip-' + str( ver ) )

def create_prefix( prefix, how, ver ):
    pdir = prefix_path( prefix, how, ver )
    try:
        if not os.path.isdir( pdir ):
            os.makedirs( pdir )
        return pdir
    except Exception as e:
        print( err_prefix, e )
        error = True
        return None

def delete_work_dir( wdir ):
    global args
    quiet = args.quiet

    if not dryrun:
        if not quiet:
            print( 'Deleting work directory (', wdir, ') ... ', end='' )
            sys.stdout.flush()
    else:
        print( '[DRY] Deleting work directory (', wdir, ') ... done ' )
        sys.stdout.flush()
        return True

    try_first   = True
    retry_count = 3
    retry_wait  = 1
    while True:
        try:
            if try_first:
                try_first = False
                shutil.rmtree( wdir )
            else:
                if sp.run( [ '/bin/sh', '-c', 'rm -f -r ' + wdir + ' > /dev/null 2>&1' ] ).returncode != 0:
                    raise Exception( 'rm -r -f ' + wdir + ' FAILD' )
            # success
            if not quiet:
                print( 'done' )
                sys.stdout.flush()
            return True

        except Exception as e:
            retry_count = retry_count - 1
            if retry_count == 0:
                print( 'failed' )
                sys.stdout.flush()
                error = True
                return False

            if quiet:
                queit = False
                print( 'delete_work_dir:', err_prefix, e )
                print( 'Deleting work directory ('+wdir+') ..retrying..', end='' )
                sys.stdout.flush()
            else:
                print( 'retrying ..', end='' )
                sys.stdout.flush()
            time.sleep( retry_wait )
            retry_wait = retry_wait * 2

# check and create work dir
def work_path( work, how, ver ):
    global args, arch, redhat_ver
    path = os.path.join( work,
                         arch + '_' +
                         'redhat-' + str( redhat_ver ) + '_' +
                         how + '_' +
                         'pip-' + str( ver ) )
    return path

def check_work( work ):
    global promtpt_rm_work

    if os.path.isfile( work ):
        print( err_prefix, work, 'is not a directory but a file' )
        error = True
        return False
    if not os.path.isdir( work ):
        return True
    if args.force:
        if not delete_work_dir( work ):
            error = True
            return False
        return True
    if not prompt_rm_work:
        print( warn_prefix, 'Work directory already exists: ', work )
        if not dryrun:
            while True:
                try:
                    prompt = "Delete work directory(ies) before install? 'yes', 'no' or 'all' [y/a/N]: "
                    choice = input( prompt ).lower()
                except:
                    print( '' )
                    error = True
                    return False

                if choice in [ 'y', 'ye', 'yes' ]:
                    break
                elif choice in [ 'a', 'al', 'all' ]:
                    prompt_rm_work = True
                    break;
                elif choice in [ 'n', 'no' ]:
                    error = True
                    return False
                else:
                    continue
    if not delete_work_dir( work ):
        error = True
        return False
    return True

def create_work( work ):
    try:
        log_dir = os.path.join( work, 'log' )
        if not os.path.isdir( log_dir ):
            os.makedirs( log_dir )
        log_path = os.path.join( log_dir, 'pip-pip.log' )
    except Exception as e:
        print( err_prefix, e )
        error = True
        return None, None
    return work, log_path

def check_file( file ):
    if dryrun:
        return True
    return os.path.isfile( file )

def do_poll( proc, t_accum, dots, tmax, intval, log_fs ):
    global args

    delta = 0.2
    t = 0.0
    i = 0
    while True:
        if t >= tmax:
            if not args.quiet:
                print( str( t_accum ), end='' )
                sys.stdout.flush()
            return None, t_accum
        if t >= i:
            i = i + intval
            t_accum = t_accum + intval
            if not args.quiet:
                print( dots, end='' )
                sys.stdout.flush()

        time.sleep( delta )
        t = t + delta

        ret = proc.poll()
        if ret is not None:
            break

    if ret != 0:
        if not args.quiet:
            print( str( t_accum ), end='' )
            log( [ ' - NG' ], log_fs, True )
        return False, t_accum

    if not args.quiet:
        print( str( t_accum ), end='' )
        log( [ ' - OK' ], log_fs, True )
    return True, t_accum

def execute( dir, cmd, log_f, log_fs, tbi ):
    global error

    if dryrun:
        log( [ '[DRY]' ] + cmd, log_fs, True )
        return True
    elif not tbi:
        log( [ '[TBI]' ] + cmd, log_fs, True )
        return False
    if error:
        log( [ msg_prefix ] + cmd + [ '-- execution skipped due to prev. error' ],
             log_fs, True )
        error = True
        return False

    try:
        log( [ msg_prefix ] + cmd, log_fs, False )
        redirect = [ '>>', log_f, '2>&1', '<', '/dev/null' ]
        if dir == None:
            cmd_list = cmd + redirect
        else:
            chdir = [ 'cd', dir ]
        cmd_list = [ '(' ] + chdir + [ '&&' ] + cmd + [ ')' ] + redirect
        shell_cmd = [ '/bin/sh', '-c', ' '.join( cmd_list ) ]
        proc = sp.Popen( shell_cmd, close_fds=True, stderr=sys.stdout )

        if not args.quiet:
            print( ' ', end='' )
            sys.stdout.flush()
        inc = [ ( '.',   10,   1 ),
                ( '.',   30,   3 ),
                ( '.',  100,  10 ),
                ( '.',  300,  30 ) ]
        t = 0
        for ( dot, tmax, inc ) in inc:
            ( ret, t ) = do_poll( proc, t, dot, tmax, inc, log_fs )
            if ret == None:
                continue
            elif ret == False:
                error = True
                time.sleep( 2 ) # wait for stdout/stderr flushing
            return ret
        while True:
            ( ret, t ) = do_poll( proc, t, '.', 10000, 100, log_fs )
            if ret == None:
                continue
            elif ret == False:
                error = True
                time.sleep( 2 ) # wait for stdout/stderr flushing
            return ret
    except Exception as e:
        log( [ '\nException:', e ], log_fs, True )
        error = True
        return False

def install_yum( pip_ver, log_f, log_fs ):
    yum_pip = 'process-in-process-v' + str( pip_ver )

    retuple = ( 'yum', yum_pip, '' )
    log( [ msg_enter, 'Yum install', yum_pip ], log_fs, True )
    if not args.quiet:
        print( 'Log File:', log_f )

    if not is_privileged( log_fs ):
        return False, retuple
    if execute( None, sudo_cmd + [ 'yum', 'reinstall', '-y', yum_pip ],
                log_f, log_fs, False ):
        return True, retuple
    return False, retuple

def install_docker( pip_ver, log_f, log_fs ):
    docker_pip = 'rikenpip/pipv' + str( pip_ver )

    retuple = ( 'docker', docker_pip, '' )
    log( [ msg_enter, 'Docker install', docker_pip ], log_fs, True )
    if not args.quiet:
        print( 'Log File:', log_f )

    if not is_privileged( log_fs ):
        return False, ( 'docker', docker_pip, '' )
    if execute( None,
                sudo_cmd + [ 'docker', 'inspect', docker_pip ],
                log_f, log_fs, False ):
        log( [ msg_prefix1, 'Removing existing image', docker_pip ], log_fs, True )
        if not execute( None,
                        sudo_cmd + [ 'docker', 'rmi', docker_pip ],
                        log_f, log_fs, False ):
            log( [ err_prefix, 'Failed to remove existing image', coker_pip ],
                 log_fs, True )
            return False, retuple
    log( [ msg_prefix1, 'Pulling existing image', docker_pip ], log_fs, True )
    if execute( None,
                sudo_cmd + [ 'docker', 'pull', docker_pip ],
                log_f, log_fs, False ):
        return True, retuple
    return False, retuple

def install_spack( prefix, how, pip_ver, log_f, log_fs ):
    global args, spack_path, git_clone

    spack_pip = 'process-in-process@' + str( pip_ver )

    retuple = ( 'spack', spack_pip, '' )
    log( [ msg_enter, 'Spack install', spack_pip ], log_fs, True )
    if not args.quiet:
        print( 'Log File:', log_f )

    if check_command( 'spack' ):
        spack_path = 'spack'
    elif spack_path == '':      # ever failed
        return False, retuple
    elif spack_path == None or not check_command( spack_path ):
        # not to install spack twice or more
        prefix_dir = create_prefix( prefix, how, pip_ver )
        if prefix_dir == None:
            return False, retuple
        log( [ msg_prefix1, 'Cloning Spack at', prefix_dir ], log_fs, True )
        if not execute( prefix_dir,
                        git_clone + [ 'https://github.com/spack/spack.git' ],
                        log_f, log_fs, False ):
            spack_path = ''
            return False, retuple
        spack_path = os.path.join( prefix_dir, 'spack', 'bin', 'spack' )

    retuple = ( 'spack', spack_pip, spack_path )
    if execute( None, [ spack_path, 'find', spack_pip ], log_f, log_fs, False ):
        log( [ msg_prefix1, 'Uninstalling', spack_pip ], log_fs, True )
        if not execute( [ spack_path, 'uninstall', spack_pip ], log_f, log_fs, False ):
            return False, retuple
    log( [ msg_prefix1, 'Installing', spack_pip ], log_fs, True )
    if not execute( None, [ spack_path, 'install', '--test=all',  spack_pip ],
    		      log_f, log_fs, False ):
        return False, retuple
    return True, retuple

def wget_install( work_dir, prefix_dir, pkgname, url, log_f, log_fs ):
    if not execute( work_dir, [ 'wget', url ], log_f, log_fs, True ):
        log( [ msg_error, 'wget_install: wget', url, '-- FAILED' ], log_fs, True )
        raise Exception()
    [ mod_tar ] = re.findall( '.*/(.*)', url )
    if not check_file( os.path.join( work_dir, mod_tar ) ):
        log( [ msg_error, 'wget_install:', mod_tar, '-- unable to find' ], log_fs, True )
        raise Exception()
    if not execute( work_dir, [ 'tar', 'xzf', mod_tar ], log_f, log_fs, True ):
        log( [ msg_error, 'wget_install: tar xzf', mod_tar, '-- FAILED' ], log_fs, True )
        raise Exception()
    os.remove( os.path.join( work_dir, mod_tar ) )
    [ mod_name ] = re.findall( '.*/(.*)\.tar.gz', url )
    mod_work = os.path.join( work_dir, mod_name )
    if not execute( mod_work,
                    [ './configure', '--prefix=' + prefix_dir ],
                    log_f, log_fs, True ):
        log( [ msg_error, 'wget_install: '
               './configure', '--prefix='+prefix_dir, 
               '['+mod_name+'] -- FAILED' ], 
             log_fs, True )
        raise Exception()
    if not execute( mod_work, [ 'make' ], log_f, log_fs, True ):
        log( [ msg_error, 'wget_install: make ['+mod_name+'] -- FAILED' ], 
             log_fs, True )
        raise Exception()
    if not execute( mod_work, [ 'make', 'install' ], log_f, log_fs, True ):
        log( [ msg_error, 'wget_install: make install ['+mod_name+'] -- FAILED' ], 
             log_fs, True )
        raise Exception()
    return '--package=' + pkgname + ':' + prefix_dir

def install_git( prefix, repo, pip_ver, work_dir, log_f, log_fs  ):
    global args, redhat_ver, git_clone

    branch_pip = 'pip-' + str( pip_ver )

    retuple = ( 'git', repo + '@' + branch_pip, '' )
    if repo == 'github':
        git_repo = 'https://github.com/RIKEN-SysSoft'
        pip = 'PiP'
    elif repo == 'git-rccs':
        git_repo = 'git@git.sys.r-ccs.riken.jp:software'
        pip = 'PIP'
    else:
        log( [ err_prefix, 'Unknown git repo:', repo ], log_fs, True )
        return False, retuple

    log( [ msg_enter, 'Git install', git_repo, 'PiP-v'+str( pip_ver ) ],
    	 log_fs, True )
    if not args.quiet:
        print( 'Log File:', log_f )

    repo_glibc = git_repo + '/' + pip + '-glibc.git'
    repo_pip   = git_repo + '/' + pip + '.git'
    repo_gdb   = git_repo + '/' + pip + '-gdb.git'
    repo_test  = git_repo + '/' + pip + '-Testsuite'

    git_pip = repo_pip + '@' + branch_pip
    retuple = ( 'git', git_pip, '' )
    if redhat_ver == 7:
        branch_glibc = 'centos/glibc-2.17-260.el7.pip.branch'
        branch_gdb   = 'centos/gdb-7.6.1-94.el7.pip.branch'
    elif redhat_ver == 8:
        branch_glibc = 'centos/glibc-2.28-72.el8_1.1.pip.branch'
        branch_gdb   = 'centos/gdb-7.6.1-94.el7.pip.branch'
    else:
        log( [ msg_error, 'Unsupported Redhat version:', str( redhat_ver ) ],
             log_fs, True )
        return False, retuple

    prefix_dir = create_prefix( prefix, repo, pip_ver )
    if prefix_dir == None:
        return False, retuple
    retuple = ( 'git', git_pip, prefix_dir )

    glibc_srcdir  = os.path.join( work_dir,     pip + '-glibc'  )
    build_script  = os.path.join( glibc_srcdir, 'build.sh'      )
    glibc_build   = os.path.join( work_dir,     'glibc_build'   )
    glibc_install = os.path.join( prefix_dir,   'glibc_install' )
    if args.noglibc:
        log( [ msg_prefix1, 'Skipping PiP-glibc build (--noglibc)' ], log_fs, True )
    else:
        log( [ msg_prefix1, 'Cloning', repo_glibc, branch_glibc ], log_fs, True )
        if not execute( work_dir,
			git_clone + [ '-b', branch_glibc, repo_glibc ],
                        log_f, log_fs, True ):
            return False, retuple
        log( [ msg_prefix1, 'Building', repo_glibc ], log_fs, True )
        if make_directory( glibc_build, True ) == None:
            return False, retuple
        if make_directory( glibc_install, True ) == None:
            return False, retuple
        if not execute( glibc_build,
                        [ build_script, glibc_install ],
                        log_f, log_fs, True ):
            return False, retuple
        piplnlibs = os.path.join( glibc_install, 'bin', 'piplnlibs.sh' )
        if not check_file( piplnlibs ):
            log( [ msg_error, 'Unable to find: ', piplnlibs ], log_fs, True )
            return False, retuple

    log( [ msg_prefix1, 'Cloning', repo_pip, branch_pip ], log_fs, True )
    if not execute( work_dir,
                    git_clone + [ '-b', branch_pip, repo_pip ],
                    log_f, log_fs, True ):
        return False, retuple

    log( [ msg_prefix1, 'Building', repo_pip ], log_fs, True )
    pip_dir = os.path.join( work_dir, pip )
    configure = os.path.join( pip_dir, 'configure' )
    if args.noglibc:
        if not execute( pip_dir,
                        [ configure, '--prefix=' + prefix_dir ],
                        log_f, log_fs, True ):
            return False, retuple
    else:
        if not execute( pip_dir,
                        [ configure,
                          '--prefix=' + prefix_dir,
                          '--with-glibc-libdir=' + glibc_install + '/lib' ],
                        log_f, log_fs, True ):
            return False, retuple
    if not execute( pip_dir, [ 'make' ], log_f, log_fs, True ):
        return False, retuple
    if not execute( pip_dir, [ 'make install' ], log_f, log_fs, True ):
        return False, retuple
    if not execute( pip_dir, [ 'make', 'doc-install' ], log_f, log_fs, True ):
        return False, retuple

    log( [ msg_prefix1, 'Testing', repo_pip ], log_fs, True )
    if not execute( work_dir, git_clone + [ repo_test ], log_f, log_fs, True ):
        return False, retuple
    test_dir = os.path.join( work_dir, pip + '-Testsuite' )
    configure = os.path.join( test_dir, 'configure' )
    if not execute( test_dir,
                    [ configure, '--with-pip=' + prefix_dir ],
                    log_f, log_fs, True ):
        return False, retuple
    if not execute( test_dir, [ 'make', 'test' ], log_f, log_fs, True ):
        return False, retuple

    if args.noglibc or args.nogdb:
        log( [ msg_prefix1, 'Skipping PiP-gdb build (--noglibc or --nogdb)' ], log_fs, True )
    else:
        log( [ msg_prefix1, 'Cloning', repo_gdb, branch_gdb ], log_fs, True )
        if not execute( work_dir,
                        git_clone + [ '-b', branch_gdb, repo_gdb ],
                        log_f, log_fs, True ):
            return False, retuple

        log( [ msg_prefix1, 'Checking required packages', repo_gdb ], log_fs, True )
        gdb_dir = os.path.join( work_dir, pip + '-gdb' )
        build_script = os.path.join( gdb_dir, 'build.sh' )
        inst_pkgs = []
        try:
            psproc = sp.Popen( [ build_script, '--missing' ], 
                               stdout=sp.PIPE, stderr=null_file )
            while True:
                mod = psproc.stdout.readline()
                if mod == '':
                    break;
                [ pkgname, url ] = mod.split()
                installed = wget_install( work_dir, prefix_dir, pkgname, url, log_f, log_fs )
                if not installed in inst_pkgs:
                    inst_pkgs += [ installed ]
        except Exception as e:
            log( [ msg_error, build_script+' --missing: FAILED', e ], log_fs, True )
            return False, retuple

        log( [ msg_prefix1, 'Building', repo_gdb ], log_fs, True )
        gdb_dir = os.path.join( work_dir, pip + '-gdb' )
        build_script = os.path.join( gdb_dir, 'build.sh' )
        if not execute( gdb_dir,
                        [ build_script,
                          '--prefix='   + prefix_dir,
                          '--with-pip=' + prefix_dir ] + inst_pkgs,
                        log_f, log_fs, True ):
            return False, retuple
        pip_gdb = os.path.join( prefix_dir, 'bin', 'pip-gdb' )
        if not check_file( pip_gdb ):
            log( [ msg_error, 'Unable to find: ', pip_gdb ], log_fs, True )
            return False, retuple
    if not args.keep:
        delete_work_dir( work_dir )
    return True, retuple

prefix_dir = check_prefix( args.prefix )
work_dir   = os.path.realpath( os.path.expanduser( args.work ) )

# check work and prefix dirs if work can be deleted
common = os.path.commonprefix( [ work_dir, prefix_dir ] )
if common is work_dir:          # this means work_dir is upper of prefix_dir
    if not args.keep:
        if not dryrun:
            print( err_prefix, 'Work dir includes prefix dir and work dir cannot be deleted.' )
            error = True
        else:
            print( warn_prefix, 'Work dir includes prefix dir and work dir cannot be deleted.' )

if error:
    sys.exit( 1 )

### NOW we can actually do the installation(s)
error = False
for how in how_list:
    for ver in pip_vers:
        if ready[ ( how, arch, redhat_ver, ver ) ]:
            check_work( work_path( work_dir, how, ver ) )
if error:
    sys.exit( 1 )

not_ready_list = []
if not args.quiet:
    print( ' ' )
    print( 'Redhat/Centos:\t\t', redhat_ver )
    print( 'CPU Architecture:\t', arch )
    print( ' ' )
    for how in how_list:
        for ver in pip_vers:
            if ready[ ( how, arch, redhat_ver, ver ) ]:
                print( how.upper(), end=' ' )
                print( '\tPiP-v' + str( ver ), end=' ' )
                if how == 'spack' and no_spack:
                    print( ' ' )
                    print( '  Prefix dir:\t', prefix_path( prefix_dir, how, ver ) )
                elif how == 'github':
                    print( ' ' )
                    print( '  Prefix dir:\t', prefix_path( prefix_dir, how, ver ) )
                    print( '  Work dir:\t',   work_path( work_dir, how, ver ) )
                elif how == 'git-rccs':
                    print( ' ' )
                    print( '  Prefix dir:\t', prefix_path( prefix_dir, how, ver ) )
                    print( '  Work dir:\t',   work_path( work_dir, how, ver ) )
                else:
                    print( '' )
            else:
                not_ready_list.append( ( how, ver ) )
    print( ' ' )

if not_ready_list != []:
    print( warn_prefix, 'The ', end='' )
    if len( not_ready_list ) == 1:
        print( 'following is ', end='' )
    else:
        print( 'followings are ', end='' )
    print( 'not ready and installtion will be skipped' )

    for ( h, v ) in not_ready_list:
        print( '\t', h.upper(), ': PiP-v' + str( v ) )
    print( ' ' )

# let's start
list_success = []
list_failure = []
list_skipped = []
nl = False

for h in how_list:
    last_how = how_list[-1]
    for pip_ver in pip_vers:
        error      = False
        last_ver = pip_vers[-1]

        if not ready[ ( h, arch, redhat_ver, pip_ver ) ]:
            list_skipped.append( ( h, arch, redhat_ver, pip_ver ) )
            continue

        ( wdir, log_path ) = create_work( work_path( work_dir, h, pip_ver ) )
        if log_path == None:
            sys.exit( 1 )

        try:
            with open( log_path, mode='w' ) as log_fs:
                now_str = datetime.datetime.now().strftime( '%Y-%m-%d %H:%M:%S' )
                print( now_str, sep, file=log_fs )

                if h == 'yum':
                    retuple = install_yum(    pip_ver, log_path, log_fs )
                elif h == 'docker':
                    retuple = install_docker( pip_ver, log_path, log_fs )
                elif h == 'spack':
                    retuple = install_spack( prefix_dir, h, pip_ver, log_path, log_fs )
                elif h == 'github':
                    retuple = install_git( prefix_dir,   h, pip_ver, wdir, log_path, log_fs )
                elif h == 'git-rccs':
                    retuple = install_git( prefix_dir,   h, pip_ver, wdir, log_path, log_fs )

                ( ok, ( how, obj, note ) ) = retuple
                if ok:
                    list_success.append( ( how, obj, note ) )
                    log( [ msg_exit,  h, 'install', obj, 'OK' ], log_fs, True )
                else:
                    list_failure.append( ( how, obj, log_path ) )
                    log( [ msg_error, h, 'install', obj, 'NG' ], log_fs, True )

                now_str = datetime.datetime.now().strftime( '%Y-%m-%d %H:%M:%S' )
                print( sep, now_str, file=log_fs )

        except Exception as e:
            print( err_prefix, e )
            print( '**** logfile:', log_path )
            sys.stdout.flush()
        except KeyboardInterrupt:
            print( '\n^C' )
            sys.exit( 1 )

        if not last_ver == pip_ver or not last_how == h:
            if not args.quiet:
                print( '' )

if list_success == [] and list_failure == []:
    # this should not happen
    sys.exit( 1 )

if not args.keep:
    if not args.quiet:
        print( '' )
    if list_failure == []:
        delete_work_dir( wdir )
    elif not args.quiet:
        print( 'the work dir is not deleted due to the error' )

if not args.quiet:
    yum_success    = False
    docker_success = False
    print( '\nSummary' )
    if list_success != []:
        for ( how, obj, note ) in list_success:
            if not dryrun:
                print( 'OK      ', end='' )
            else:
                print( '[DRY] ', end='' )
            if note == '':
                print( how, obj )
            else:
                print( how, obj, note )

            if how == 'yum':
                yum_success = True
            elif how == 'docker':
                docker_success = True

    if list_skipped != []:
        for ( how, arch, redhat, pip_ver ) in list_skipped:
            print( 'SKIPPED', how, arch, 'redhat'+str(redhat), 'PiP-v'+str(pip_ver) )

    if list_failure != []:
        for ( how, obj, log_path ) in list_failure:
            print( 'NG      ', end='' )
            if log_path == '':
                print( how, obj )
            else:
                print( how, obj, 'LOG: ' + log_path )

    if yum_success or docker_success:
        print( '' )

    if yum_success:
        print( 'YUM: PiP RPM packages are installed in /usr' )

    if docker_success:
        print( 'DOCKER: To run the PiP Docker image:' )
        print( '        $ [sudo] docker run -it rikenpip/pip-v<PiP-Version> /bin/bash' )

null_file.close()
if list_failure != []:
    sys.exit( 1 )

sys.exit( 0 )
