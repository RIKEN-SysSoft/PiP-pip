#!/bin/sh

cmd=$0
cwd=`pwd`

pip_default_version=2

begin_str=">>>"
dash="-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-="

print_usage () {
    echo "`basename $cmd` --how=<HOW> [<OPTIONS>]"
    echo "   OPTIONS:"
    echo "     --how=yum|docker|spack|github"
    echo "     --version=2|3         # PiP version"
    echo "     --prefix=<PREFIX_DIR> # installing dir (git, spack)"
    echo "     --work=<WORKING_DIR>  # working dir"
    echo "     --clean               # remove working dir. when succeeded"
    echo "     --sudo                # allow sudo (yum, docker)"
    echo "     --dryrun              # dry run"
    echo "     --help | --usage      # show usage"
    exit 1
}

dot_exec=""
if ! [ -x ./dot-exec ]; then
    make
    if [ -x ./dot-exec ]; then
	dot_exec=`dirname $cmd`/dot-exec
    fi
fi

if ! [ -f /etc/redhat-release ]; then
    echo "ERROR: Unsupported Linux distribution"
    flag_error=true
fi
release=`cat /etc/redhat-release`
case $release in
    *Linux*7.*) linux_version=7;;
    *Linux*8.*) linux_version=8;;
    *)		echo "ERROR: Unsupported Linux distribution: $release";
		flag_error=true;;
esac

config_guess=`./config.guess`
case $config_guess in
    x86_64-*)  arch=x86_64;;
    aarch64-*) arch=aarch64;;
    *)	       echo "ERROR: Unsupported architecture: $config_guess";
		flag_error=true;;
esac

prefix=""
work=""
pip_version=""
how=""
sudo=""
flag_any=false
flag_all=false
flag_sudo=false
flag_clean=false
flag_dryrun=false
flag_error=false

while [ $# -gt 0 ]; do
    case $1 in
	--prefix=*)	prefix=`echo "$1" | cut -f 2 -d "="`;;
	-p*)		shift; prefix=$1;;
	--work=*)	work=`echo "$1" | cut -f 2 -d "="`;;
	-b*)		shift; work=$1;;
	--version=*)	pip_version=`echo "$1" | cut -f 2 -d "="`;;
	-v*)		shift; pip_version=$1;;
	--how=*)	how=`echo "$1" | cut -f 2 -d "="`;;
	-*how)		shift; how=$1;;
	-c*|--clean)	flag_clean=true;;
	-d*|--dry|--dryrun) flag_dryrun=true;;
	--help|-*usage*)	print_usage;;
	*)		echo "ERROR: Unknown option: $1"; print_usage;;
    esac
    shift
done

is_privileged () {
    if [ x"$USER" == root ]; then
	return 0
    fi

    able_to_sudo=false;
    if sudo -S true < /dev/null; then
	able_to_sudo=true;
    fi

    if $able_to_sudo; then
	if $flag_sudo; then
	    sudo="sudo "
	    return 0
	else
	    echo "ERROR: --sudo option is required"
	fi
    else
	if $flag_sudo; then
	    echo "ERROR: $USER is not sudo-able"
	else
	    echo "ERROR: --sudo option is required and $USER is not sudo-able"
	fi
    fi
    sudo=""
    return 1
}

is_upper () {
    path0=$1
    path1=$2
    if [ $path0 == $path1 ]; then return true; fi
    case $path0 in
	"${path1}/"*) return true;;
    esac
    return flase
}

log_echo () {
    logfile=$1
    shift
    if ! $flag_dryrun; then
	echo "$@" >> $logfile
	echo "$@"
    else
	echo "DRYRUN: $@"
    fi
}

work_notyet () {
    logfile=$1
    shift
    log_echo $logfile "${sudo}$@ -- TBI"
}

work () {
    logfile=$1
    shift
    log_echo $logfile $@
    if ! $flag_dryrun; then
	exst=0
	if [ x"$dot_exec" != x ]; then
	    $dot_exec ${sudo}$@ >> $logfile 2>&1 &
	    exst=$?
	else
	    ${sudo}$@ >> $logfile 2>&1 &
	    pid=$!
	    while kill -0 $pid > /dev/null 2>&1; do
		sleep 1
		echo -n "."
	    done
	    wait $pid
	fi
	exst=$?
	if [ $exst == 0 ]; then
	    log_echo $logfile " SUCCEEDED"
	else
	    log_echo $logfile " FAILED"
	    flag_error=true
	fi
    fi
    return $exst
}

change_dir () {
    if ! $flag_dryrun; then cd $1; fi
}

make_dir () {
    if ! $flag_dryrun; then mkdir $@; fi
}

log_file () {
    log_dir=$1
    log_file=$2
    logfile=${log_dir}/${log_file}

    if ! $flag_dryrun; then
	error=false
	if ! [ -d $log_dir ]; then
	    if ! make_dir -p $log_dir > /dev/null 2>&1; then
		error=true
	    fi
	fi
	if ! $error; then
	    hostname -f >  $logfile 2>&1
	    date        >> $logfile 2>&1
	    echo $dash  >> $logfile 2>&1
	else
	    flag_error=true
	fi
    fi
    echo $logfile	# return
}

case "$pip_version" in
    -1) pip_version="1";		# hidden, deprecated version
	if [ $linux_version = "8" ]; then
	    echo "ERROR: RHEL8/CentOS8 is not supported by PiP-v1";
	    flag_error=true;
	fi;;
    2|3) true;;
    all|ALL) flag_all=true;;
    "")  pip_version=$pip_default_version;;
    *)   echo "ERROR: Illegal PiP version: $pip_version"; print_usage;;
esac

case "$how" in
    yum)			how=yum;;
    docker|DOCKER)		how=docker;;
    spack|SPACK)		how=spack;;
    git|GIT|github|GITHUB)	how=github;;
    git:rccs|git-rccs)		how=rccs;;
    all|ALL)			flag_any=true;;
    "")				echo "ERROR: --how option must be specified";
				print_usage;;
    *)				echo "ERROR: Unknown --how option: $how";
				print_usage;;
esac

pip_build () {
    repo=$1
    version=$2

    case $repo in
	github)   pip="PiP";
	          git_repo="https://github.com/RIKEN-SysSoft";;
	rccs)     pip="PIP";
	          git_repo="git@git.sys.r-ccs.riken.jp:software";;
	*)	  echo "ERROR: Unknown repo: $repo";
	          flag_error=true;
		  return 1;;
    esac

    if $flag_all; then
	work_base=${work}/${repo}-${arch}_redhat-${linux_version}_pip-${version}
	prefix_base=${prefix}/${repo}-${arch}_redhat-${linux_version}_pip-${version}
    else
	work_base=${work}
	prefix_base=${prefix}
    fi

    repo_glibc=${git_repo}/${pip}-glibc.git
    repo_pip=${git_repo}/${pip}.git
    repo_gdb=${git_repo}/${pip}-gdb.git

    branch_pip=pip-$version

    if [ $linux_version == 7 ]; then
	branch_glibc=centos/glibc-2.17-260.el7.pip.branch
	branch_gdb=centos/gdb-7.6.1-94.el7.pip.branch
    else
	branch_glibc=centos/glibc-2.28-72.el8_1.1.pip.branch
	branch_gdb=centos/gdb-7.6.1-94.el7.pip.branch # temporaly should be fixed !!
    fi

    if [ -d $work_base ]; then
	echo "ERROR: Work dir. exists already: $work_base"
	if ! $flag_dryrun; then
	    flag_error=true
	    return 1
	fi
    fi
    make_dir -p $work_base
    change_dir $work_base

    log_base=$work_base/log
    build_log=`log_file $log_base pip-glibc-build.log`

    log_echo $build_log $dash
    log_echo $build_log "PiP:        ${pip}-v${version}"
    log_echo $build_log "Linux:      $linux_version [$release]"
    log_echo $build_log "Arch:       $arch [$config_guess]"
    log_echo $build_log "Repo PiP:   $repo_pip / $branch_pip"
    log_echo $build_log "     Glibc: $repo_glibc / $branch_glibc"
    log_echo $build_log "     GDB:   $repo_gdb / $branch_gdb"
    log_echo $build_log "Work:       $work_base"
    log_echo $build_log "Prefix:     $prefix_base"
    log_echo $build_log $dash

    log_echo $build_log "[ PiP-Glibc ]"

    make_dir $work_base/${pip}-glibc
    log_echo $build_log "$begin_str Cloning PiP-glibc"
    work $build_log git clone -b $branch_glibc $repo_glibc

    log_echo $build_log "$begin_str Building PiP-glibc"
    glibc_builddir=${work_base}/glibc-build
    make_dir $glibc_builddir
    (
	change_dir $glibc_builddir
	work $build_log ../${pip}-glibc/build.sh ${prefix_base}/glibc-install
    )
    if ! $flag_dryrun; then
	if ! [ -x ${prefix_base}/glibc-install/bin/piplnlibs.sh ]; then
	    log_echo $build_log "FAIL"
	    flag_error=true
	fi
    fi

    build_log=`log_file $log_base pip-lib-build.log`
    log_echo $build_log "[ PiP Lib. ]"

    log_echo $build_log "$begin_str Cloning PiP lib."
    work $build_log git clone -b $branch_pip $repo_pip

    log_echo $build_log "$begin_str Building PiP lib."
    (
	change_dir $pip
	work $build_log ./configure \
	    --prefix=${prefix_base}/pip-install \
	    --with-glibc-libdir=${prefix_base}/glibc-install/lib
	if [ $? -ne 0 ]; then return 1; fi
	if ! work $build_log make;                 then return 1; fi
	if ! work $build_log make check;           then return 1; fi
	if ! work $build_log make install;         then return 1; fi
	if ! work $build_log make check-installed; then return 1; fi
	if ! work $build_log make doc-install;     then return 1; fi
    )
    if ! $flag_dryrun; then
	if ! [ -x ${prefix_base}/pip-install/bin/pipcc ]; then
	    log_echo $build_log "FAIL"
	    flag_error=true
	fi
    fi

    build_log=`log_file $log_base pip-gdb-build.log`
    log_echo $build_log "[ PiP-gdb ]"

    log_echo $build_log "$begin_str Cloning PiP-gdb"
    work $build_log git clone -b $branch_gdb $repo_gdb

    log_echo $build_log "$begin_str Building PiP-gdb"
    (
	change_dir ${pip}-gdb
	work $build_log ./build.sh --prefix=${prefix_base}/gdb-install \
	    --with-pip=${prefix_base}/pip-install
    )
    if ! $flag_dryrun; then
	if ! [ -x ${prefix_base}/gdb-install/bin/pip-gdb ]; then
	    log_echo $build_log "FAIL"
	    flag_error=true
	fi
    fi

    if $flag_error; then return 1; fi
    return 0
}

pip_git () {
    repo=$1

    if ! which git > /dev/null 2>&1; then
	echo "ERROR: Unable to find 'git' command"
	flag_error=true
	return 1
    fi

    if $flag_all; then
	if [ $linux_version == 7 ]; then
	    versions="1 2 3"
	else
	    versions="2 3"
	fi
	for ver in $versions; do
	    pip_build $repo $ver
	    if [ $? -ne 0 ]; then flag_error=true; fi
	done
    else
	pip_build $repo $pip_version
	if [ $? -ne 0 ]; then flag_error=true; fi
    fi
}

do_docker () {
    logfile=$1
    pip_ver=$2
    image_name=rikenpip/pipv${pip_ver}
    if ${sudo}docker inspect $image_name > /dev/null 2>&1; then
	log_echo $logfile "$begin_str Docker removing $image_name"
	work_notyet $logfile docker rmi $image_name
    fi
    log_echo $logfile "$begin_str Docker pulling $image_name"
    work_notyet $logfile docker pull $image_name
    return $?
}

pip_docker () {
    if ! which docker > /dev/null 2>&1; then
	echo "ERROR: Unable to find 'docker' command"
	flag_error=true
	return 1
    fi
    if ! is_privileged; then
	if ! $flag_dryrun; then
	    echo "Docker installation is skipped due to the error"
	    flag_error=true
	    return 1
	fi
    fi

    docker_log=`log_file $work/log pip-docker.log`
    if $flag_all; then
	if [ $linux_version == 7 ]; then
	    versions="1 2 3"
	else
	    versions="2 3"
	fi
	for ver in $versions; do
	    do_docker $docker_log $ver
	    if [ $? -ne 0 ]; then
		flag_error=true
	    fi
	done
    else
	do_docker $docker_log $ver
	if [ $? -ne 0 ]; then
	    flag_error=true
	fi
    fi
    sudo=""
}

pip_spack () {
    spack_log=`log_file $work/log pip-spack.log`
    pckg="process-in-process"
    if which spack > /dev/null 2>&1; then
	spack="spack"
    else
	if ! [ -d $prefix ]; then
	    make_dir -p $prefix
	fi
	change_dir $prefix
	log_echo $spack_log "$begin_str Cloning Spack -- $prefix"
	work_notyet $spack_log git clone https://github.com/spack/spack.git
	spack=$prefix/spack/bin/spack
    fi
    if $flag_all; then
	versions="2 3"
	for ver in $versions; do
	    if $spack find $pckg@$ver > /dev/null 2>&1; then
		log_echo $spack_log "$begin_str Spack uninstalling existing $pckg@$ver"
		work_notyet $spack_log $spack uninstall $pckg@$ver
	    fi
	    log_echo $spack_log "$begin_str Spack installing $pckg@$ver"
	    work_notyet $spack_log $spack install --test=all $pckg@$ver
	done
    else
	if $spack find $pckg@$pip_version > /dev/null 2>&1; then
	    log_echo $spack_log "$begin_str Spack uninstalling existing $pckg@$pip_version"
	    work_notyet $spack_log $spack uninstall $pckg@$pip_version
	fi
	log_echo $spack_log "$begin_str Spack Installing $pckg@$pip_version"
	work_notyet $spack_log $spack install --test=all $pckg@$pip_version
    fi
}

pip_yum () {
    if ! is_privileged; then
	if ! $flag_dryrun; then
	    echo "Yum installation is skipped due to the error"
	    flag_error=true
	    return 1
	fi
    fi
    yum_log=`log_file $work/log pip-yum.log`
    if $flag_all; then
	versions="1 2 3"
	for ver in $versions; do
	    log_echo $yum_log "$begin_str Yum installing PiP-v$ver"
	    work_notyet $yum_log yum install -y process-in-process-v$ver
	done
    else
	log_echo $yum_log "$begin_str Yum installing PiP-v$pip_version"
	work_notyet $yum_log yum install -y process-in-process-v$pip_version
    fi
    sudo=""
    return 0
}

install_chooser () {
    method=$1
    case $method in
	docker) pip_docker;;
	spack)  pip_spack;;
	yum)    pip_yum;;
	github) pip_git $method;;
	rccs)   pip_git $method;;
	*)      echo "Unknown --how option: $method";;
    esac
}

if [ x"$prefix" == x ]; then
    prefix="install"
fi
pfx=`realpath $prefix 2> /dev/null`
if [ $? != 0 ]; then
    echo "ERROR: Invalid prefix path: $prefix"
    flag_error=true
fi
prefix=$pfx

if [ x"$work" == x ]; then
    work="work"
fi
wrk=`realpath $work 2> /dev/null`
if [ $? != 0 ]; then
    echo "ERROR: Invalid work path: $work"
    flag_error=true
fi
work=$wrk

if $flag_error; then exit 1; fi

if $flag_clean; then
    if is_upper $work $prefix; then
	echo "WARNING: --clean is disabled since work dir. includes prefix dir.";
	flag_clean=false;
    fi
    if is_upper $work $cwd; then
	echo "WARNING: --clean is disabled since work dir. include current dir.";
	flag_clean=false;
    fi
fi

if $flag_any; then
    flag_all=true
    install="yum docker spack github rccs"
    for inst in $install; do
	install_chooser $inst
    done
else
    install_chooser $how
fi

if $flag_error; then
    exit 1
elif $flag_clean; then
    if [ x"$work" != x ]; then
	rm -f -r $work
    fi
fi
exit 0

