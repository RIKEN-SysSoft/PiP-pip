#!/usr/bin/env python
# -*- mode:python -*-

# $PIP_license: <Simplified BSD License>
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
#
#     Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
# THE POSSIBILITY OF SUCH DAMAGE.
# $
# $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),
# System Software Development Team, 2016-2020
# $
# $PIP_PIP: Version 1.0.0$
#
# $Author: Atsushi Hori (R-CCS) mailto: ahori@riken.jp or ahori@me.com
# $

"PiP-pip: PiP (Process-in-Process) package installation program"

from __future__ import print_function
import datetime
import time
import argparse
import shutil
import os
import sys
import subprocess as sp
import re

docker_img   = 'rikenpip/pip-v'

spack_url     = 'https://github.com/spack/spack.git'
spack_url_dev = 'git@git.sys.r-ccs.riken.jp:software/PIP-Spack.git'

git_url_tab   = { 'github'   : 'https://github.com/RIKEN-SysSoft',
                  'git-rccs' : 'git@git.sys.r-ccs.riken.jp:software' }

git_repo_tab  = { 'github'   : { 'glibc': 'PiP-glibc.git',
                                 'pip'  : 'PiP.git',
                                 'gdb'  : 'PiP-gdb.git',
                                 'test' : 'PiP-Testsuite.git' },
                  'git-rccs' : { 'glibc': 'PIP-glibc.git',
                                 'pip'  : 'PIP.git',
                                 'gdb'  : 'PIP-gdb.git',
                                 'test' : 'PIP-Testsuite.git' } }

gnu_branch_tab = { 7 : ( 'centos/glibc-2.17-260.el7.pip.branch',
                         'centos/gdb-7.6.1-94.el7.pip.branch' ),
                   8 : ( 'centos/glibc-2.28-72.el8_1.1.pip.branch',
                         'centos/gdb-7.6.1-94.el7.pip.branch' ) }

# Ready list: (how, arch, redhat, pip )
ready = { ( 'yum',      'x86_64',  7, 1 ): ( True,  True  ),
          ( 'yum',      'x86_64',  7, 2 ): ( False, False ),
          ( 'yum',      'x86_64',  7, 3 ): ( False, False ),
          ( 'yum',      'x86_64',  8, 1 ): ( False, False ),
          ( 'yum',      'x86_64',  8, 2 ): ( False, False ),
          ( 'yum',      'x86_64',  8, 3 ): ( False, False ),
          ( 'yum',      'aarch64', 7, 1 ): ( False, False ),
          ( 'yum',      'aarch64', 7, 2 ): ( False, False ),
          ( 'yum',      'aarch64', 7, 3 ): ( False, False ),
          ( 'yum',      'aarch64', 8, 1 ): ( False, False ),
          ( 'yum',      'aarch64', 8, 2 ): ( False, False ),
          ( 'yum',      'aarch64', 8, 3 ): ( False, False ),

          ( 'docker',   'x86_64',  7, 1 ): ( True,  True  ),
          ( 'docker',   'x86_64',  7, 2 ): ( False, False ),
          ( 'docker',   'x86_64',  7, 3 ): ( False, False ),
          ( 'docker',   'x86_64',  8, 1 ): ( False, False ),
          ( 'docker',   'x86_64',  8, 2 ): ( False, False ),
          ( 'docker',   'x86_64',  8, 3 ): ( False, False ),
          ( 'docker',   'aarch64', 7, 1 ): ( False, False ),
          ( 'docker',   'aarch64', 7, 2 ): ( False, False ),
          ( 'docker',   'aarch64', 7, 3 ): ( False, False ),
          ( 'docker',   'aarch64', 8, 1 ): ( False, False ),
          ( 'docker',   'aarch64', 8, 2 ): ( False, False ),
          ( 'docker',   'aarch64', 8, 3 ): ( False, False ),

          ( 'spack',    'x86_64',  7, 1 ): ( False, False ),
          ( 'spack',    'x86_64',  7, 2 ): ( False, True  ),
          ( 'spack',    'x86_64',  7, 3 ): ( False, True  ),
          ( 'spack',    'x86_64',  8, 1 ): ( False, False ),
          ( 'spack',    'x86_64',  8, 2 ): ( False, True  ),
          ( 'spack',    'x86_64',  8, 3 ): ( True,  True  ),
          ( 'spack',    'aarch64', 7, 1 ): ( False, False ),
          ( 'spack',    'aarch64', 7, 2 ): ( False, True  ),
          ( 'spack',    'aarch64', 7, 3 ): ( False, True  ),
          ( 'spack',    'aarch64', 8, 1 ): ( False, False ),
          ( 'spack',    'aarch64', 8, 2 ): ( False, True  ),
          ( 'spack',    'aarch64', 8, 3 ): ( False, True  ),

          ( 'github',   'x86_64',  7, 1 ): ( True,  True  ),
          ( 'github',   'x86_64',  7, 2 ): ( True,  True  ),
          ( 'github',   'x86_64',  7, 3 ): ( True,  True  ),
          ( 'github',   'x86_64',  8, 1 ): ( False, False ),
          ( 'github',   'x86_64',  8, 2 ): ( True,  True  ),
          ( 'github',   'x86_64',  8, 3 ): ( True,  True  ),
          ( 'github',   'aarch64', 7, 1 ): ( True,  True  ),
          ( 'github',   'aarch64', 7, 2 ): ( True,  True  ),
          ( 'github',   'aarch64', 7, 3 ): ( True,  True  ),
          ( 'github',   'aarch64', 8, 1 ): ( False, False ),
          ( 'github',   'aarch64', 8, 2 ): ( True,  True  ),
          ( 'github',   'aarch64', 8, 3 ): ( True,  True  ),

          ( 'git-rccs', 'x86_64',  7, 1 ): ( True,  True  ),
          ( 'git-rccs', 'x86_64',  7, 2 ): ( True,  True  ),
          ( 'git-rccs', 'x86_64',  7, 3 ): ( True,  True  ),
          ( 'git-rccs', 'x86_64',  8, 1 ): ( False, False ),
          ( 'git-rccs', 'x86_64',  8, 2 ): ( True,  True  ),
          ( 'git-rccs', 'x86_64',  8, 3 ): ( True,  True  ),
          ( 'git-rccs', 'aarch64', 7, 1 ): ( True,  True  ),
          ( 'git-rccs', 'aarch64', 7, 2 ): ( True,  True  ),
          ( 'git-rccs', 'aarch64', 7, 3 ): ( True,  True  ),
          ( 'git-rccs', 'aarch64', 8, 1 ): ( False, False ),
          ( 'git-rccs', 'aarch64', 8, 2 ): ( True,  True  ),
          ( 'git-rccs', 'aarch64', 8, 3 ): ( True,  True  )
}

MSG_ENTER   = '>>>'
MSG_EXIT    = '<<<'
MSG_ERROR   = '<<E'
MSG_PREFIX  ='---'
MSG_PREFIX1 ='###'
ERR_PREFIX  ='ERROR:'
WARN_PREFIX ='WARNING:'
SEP = '\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n'

sudo_cmd       = []
prompt_prefix  = False
prompt_rm_all  = False
FLAG_SUBDIR    = False
spack_path     = None
DRYRUN         = False
FLAG_QUIET     = False
SUDO_ERR       = False
ERROR          = False

def mesg( words, newline, fs ):
    "general print message func"
    if words != []:
        for word in words[0:-1]:
            print( word, end=' ', file=fs )
        if newline:
            print( words[-1], file=fs )
        else:
            print( words[-1], end='', file=fs )
    elif newline:
        print( '', file=fs )
    fs.flush()

def message( words, newline=True, log=None, logonly=False ):
    "print message"

    if not logonly and not FLAG_QUIET:
        mesg( words, newline, sys.stdout )
    if log is not None and not DRYRUN:
        mesg( words, newline, log )

def err_msg( words, log=None ):
    "print error message"
    global ERROR

    ERROR = True
    message( [ ERR_PREFIX ] + words, log=log )

def warn_msg( words, newline=True, log=None ):
    "print warning message"
    message( [ WARN_PREFIX ] + words, newline, log=log )

urlparser = None
def concat_urls( url0, url1 ):
    "concatenate URLs"
    global urlparser

    if urlparser == None:
        try:
            import urllib.parse
            urlparser = urllib.parse
        except Exception as e0:
            try:
                import urlparse
                urlparser = urlparse
            except Exception as e1:
                err_msg( [ 'No urllib module:',   e0 ] )
                err_msg( [ 'No urlparse module:', e1 ] )
                NULL_FILE.close()
                sys.exit( 1 )
    return urlparser.urljoin( url0+'/', url1 )

GIT_CLONE = [ 'git', 'clone' ]
NULL_FILE = open( os.devnull, 'w' )

def get_redhat_version():
    "obtain RedHat version"
    try:
        with open( '/etc/redhat-release', mode='r' ) as f:
            rhel = f.readline().split()
            while True:
                if rhel == []:
                    raise Exception( 'Unknown /etc/readhat-release content' )
                token = rhel.pop(0)
                if token == 'release':
                    verstr = rhel.pop(0)
                    ver = int( verstr.split( '.' ).pop( 0 ) )
                    return ver
    except Exception:
        err_msg( [ "Not a RedHat distribution" ] )
        sys.exit( 1 )

def cpu_arch():
    "obtain CPU architecture"
    return sp.check_output( [ 'uname', '-m' ] ).decode().split().pop(0)

def is_privileged( log_fs ):
    "check if the current user can sudo"
    global sudo_cmd, SUDO_ERR

    if SUDO_ERR:
        return False

    user = os.environ['USER']
    if user == 'root':
        # no need of sudo
        sudo_cmd = []
        return True

    if sudo_cmd is not None:
        if sudo_cmd != []:
            return True

    sudo_rc = sp.call( [ '/bin/sh', '-c', 'sudo -S true' ],
                       stdout=NULL_FILE, stderr=NULL_FILE )
    if sudo_rc == 0:
        able_to_sudo = True
    else:
        able_to_sudo = False

    if ARGS.sudo:
        if able_to_sudo:
            sudo_cmd = [ 'sudo' ]
            return True
        sudo_cmd = []
        if not DRYRUN:
            err_msg(  [ "'"+user+"'", 'is unable to sudo' ], log=log_fs )
            SUDO_ERR = True
        else:
            warn_msg( [ "'"+user+"'", 'is unable to sudo' ], log=log_fs )
    elif DRYRUN:
        warn_msg( [ "'"+user+"'", 'is unable to sudo and no --sudo option' ],
                  log=log_fs )
    else:
        SUDO_ERR = True
        if able_to_sudo:
            err_msg(  [ '--sudo option is required to sudo' ], log=log_fs )
        else:
            err_msg(  [ "'"+user+"'", 'is unable to sudo and no --sudo option' ],
                      log=log_fs )
    return False

cmd = sys.argv[0]

parser = argparse.ArgumentParser( description='pip-pip: Process-in-Process '+
                                  'package installing program',
                                  add_help = True )
parser.add_argument( '--how', '-H',
                     help    = 'specifying how to install ' \
                         '[yum|docker|spack|GITHUB]',
                     type    = str,
                     action  = 'append' )
parser.add_argument( '--version', '-v',
                     help    = "specifying PiP version (2 or 3. default '2')",
                     type    = str,
                     action  = 'append' )
parser.add_argument( '--prefix', '-p',
                     help    = "install directory " \
                         "([spack,] github. default 'install')",
                     type    = str,
                     default = 'install',
                     nargs   = '?' )
parser.add_argument( '--work', '-w',
                     help    = "working directory (default 'work')",
                     type    = str,
                     default = 'work',
                     nargs   = '?' )
parser.add_argument( '--keep', '-k',
                     help    = 'keep working directory. ' +
                     'Work is deleted when succeeded by default',
                     action  = 'store_true' )
parser.add_argument( '--sudo', '-s',
                     help    = 'allow sudo (yum, docker)',
                     action  = 'store_true' )
parser.add_argument( '--yes', '-y',
                     help    = "answer 'yes' to the prompt(s)",
                     action  = 'store_true' )
parser.add_argument( '--quiet', '-q',
                     help    = 'quiet mode',
                     action  = 'store_true' )
parser.add_argument( '--noglibc', '-noglibc',
                     help    = 'do not build PiP-glibc and PiP_gdb (github)',
                     action  = 'store_true' )
parser.add_argument( '--nogdb', '-nogdb',
                     help    = 'do not build PiP_gdb (github)',
                     action  = 'store_true' )
parser.add_argument( '--notest', '-notest',
                     help    = 'Not to test installed PiP',
                     action  = 'store_true' )
parser.add_argument( '--noupdate', '-noupdate',
                     help    = 'Do not update if PiP is already installed',
                     action  = 'store_true' )
parser.add_argument( '--threshold', '-t',
                     type    = int,
                     nargs   = '?',
                     default = 10,
                     help     = 'The threshold of the number of PiP testsuite ' \
                     'errors (default 10)' )
parser.add_argument( '--develop',
                     help    = 'For developing PiP-pip',
                     action  = 'store_true' )
parser.add_argument( '--dryrun', '--dry', '-d',
                     help    = 'dry run',
                     action  = 'store_true' )
ARGS = parser.parse_args()

DRYRUN     = ARGS.dryrun
FLAG_QUIET = ARGS.quiet

test_threshold = ARGS.threshold
if test_threshold < 0:
    test_threshold = 10
os.environ['PIP_TEST_THRESHOLD'] = str(test_threshold)

def check_command( command ):
    "check if the Linux command exists"

    if DRYRUN:
        return True

    try:
        if sp.check_call( ['sh','-c','which '+command+' >/dev/null 2>&1'] ) == 0:
            return True
    except:
        return False
    return False

def expand( lst ):
    "flatten list"
    if lst == [] or lst is None:
        return []
    token = lst.pop( 0 )
    if ',' in token:
        return token.split( ',' ) + expand( lst )
    if '+' in token:
        return token.split( '+' ) + expand( lst )
    return [ token ] + expand( lst )

## check how
how_list = expand( ARGS.how )
how_all = [ 'yum', 'docker', 'spack', 'github' ]
how_ALL = how_all + [ 'git-rccs' ]

if 'all' in how_list:
    how_list = how_all
elif 'ALL' in how_list:
    how_list = how_ALL
elif how_list == []:
    how_list = [ 'github' ]
else:
    errlist = []
    howlist = []
    for h in how_list:
        if not h in how_ALL:
            errlist.append( h )
    if errlist != []:
        if len(errlist) == 1:
            err_msg( [ errlist[0], 'is not acceptable value of --how']  )
        else:
            err_msg( [ ','.join(errlist), 'are not acceptable values of --how']  )
        parser.print_help()
    else:
        for h in how_ALL:
            if h in how_list:
                howlist.append( h )
    if howlist == []:
        ERROR = True
    how_list = howlist
if len( how_list ) > 1:
    FLAG_SUBDIR = True

if 'yum' in how_list:
    if not check_command( 'yum' ):
        err_msg( [ "'yum' command not found" ] )
    else:
        is_privileged( None )
if 'docker' in how_list:
    if not check_command( 'docker' ):
        err_msg( [ "'docker' command not found" ] )
    else:
        is_privileged( None )
if 'spack' in how_list:
    if check_command( 'spack' ):
        spack_path = 'spack'
    elif not check_command( 'git' ):
        err_msg( [ "'git' command not found (required to install Spack)" ] )
if 'github' in how_list or 'git-rccs' in how_list:
    if not check_command( 'git' ):
        err_msg( [ "'git' command not found" ] )

## check Linux distribution and version
redhat_version = get_redhat_version()
if not redhat_version in [ 7, 8 ]:
    err_msg( [ 'RedHat/CentOS-'+str(redhat_version), 'is not supported' ] )
    sys.exit( 1 )

## Check PiP version
version = expand( ARGS.version )
pip_vers = []
if 'ALL' in version:
    if redhat_version == 7:
        pip_vers = [ 1, 2, 3 ]
    else:
        pip_vers = [ 2, 3 ]
elif 'all' in version:
    pip_vers = [ 2, 3 ]
elif version == []:
    pip_vers = [ 2 ]
else:
    version = sorted( set( version ) )
    ver_acceptable = [ -1, 2, 3 ]
    errlist = []
    for ver_str in version:
        try:
            ver = int( ver_str )
            if ver in ver_acceptable:
                pip_vers.append( abs( ver ) )
            else:
                errlist.append( ver_str )
        except:
            errlist.append( ver_str )
    errlen = len( errlist )
    if errlen > 0:
        if errlen == 1:
            err_msg( [ errlist[0], 'is not an acceptable value of --version' ] )
        else:
            err_msg( [ ','.join(errlist),
                       'are not acceptable values of --version' ] )
if len( pip_vers ) > 1:
    FLAG_SUBDIR = True

# check arch
arch = cpu_arch()
if not arch in [ 'x86_64', 'aarch64' ]:
    err_msg( [ arch, 'is not supported by PiP' ] )

def make_directory( path, flag ):
    "make directory"

    if not DRYRUN:
        try:
            if os.path.isdir( path ):
                if flag:
                    return path
                err_msg( [ 'Dirctory (' + path + ') already exists' ] )
                return None
            os.mkdir( path )
            return path
        except Exception as e:
            err_msg( [ 'make_directory:', e ] )
            return None
    else:
        return dir

# check and create prefix dir
def check_prefix( prefix_arg ):
    "check the prefix directory"
    global ERROR

    pref = os.path.realpath( os.path.expanduser( prefix_arg ) )
    if DRYRUN:
        return pref
    if os.path.isfile( pref ):
        err_msg( [ pref, 'is not a directory but a file' ] )
        return None
    if os.path.isdir( pref ):
        if not ARGS.yes and not prompt_prefix:
            warn_msg( [ 'Prefix directory already exists: ', pref ] )
            while True:
                try:
                    prompt  = "Are you sure to install into '"
                    prompt += pref+"' directory? 'yes' or 'no' [y/a/n]: "
                    choice = input( prompt ).lower()
                except:
                    message( [] )
                    NULL_FILE.close()
                    sys.exit( 1 )

                if choice == '':
                    continue
                if choice[0] == 'y':
                    break
                if choice[0] == 'a':
                    prompt_prefix = True # never ask again
                    break
                if choice[0] == 'n':
                    ERROR = True
                    break
                continue
    return pref

def prefix_path( prefix, how, ver ):
    "make the prefix path"
    global ERROR

    if not FLAG_SUBDIR:
        return prefix
    return os.path.join( prefix,
                         arch + '_' +
                         'redhat-' + str( redhat_version ) + '_' +
                         how + '_' +
                         'pip-' + str( ver ) )

def create_prefix( prefix, how, ver ):
    "create the prefix directory"

    pdir = prefix_path( prefix, how, ver )
    if DRYRUN:
        return pdir
    try:
        if not os.path.isdir( pdir ):
            os.makedirs( pdir )
        return pdir
    except Exception as e:
        err_msg( [ 'create_prefix:', e ] )
        return None

def delete_work_dir( wdir ):
    "delete work directory"

    if DRYRUN:
        message( [ '[DRY] Deleting work directory ('+wdir+') .. done' ] )
        return True
    message( [ 'Deleting work directory ('+wdir+') ..' ], newline=False )

    try_shutil  = True
    retry_count = 3
    retry       = retry_count
    retry_wait  = 1
    while True:
        try:
            if try_shutil:
                try_shutil = False
                shutil.rmtree( wdir )
            else:
                if sp.run( [ '/bin/sh', '-c', 'rm -f -r ' + wdir ],
                           check=False,
                           stdout=NULL_FILE, stderr=NULL_FILE ).returncode != 0:
                    raise Exception( 'rm -r -f ' + wdir + ' FAILD' )
            # success
            message( [ ' done' ] )
            return True

        except:
            if retry == 0:
                err_msg( [ 'failed' ] )
                return False
            message( [ 'retrying..' ], newline=False )
            time.sleep( retry_wait )
            retry_wait *= 2
            retry -= 1

# check and create work dir
def work_path( work, how, ver ):
    "create work directory path"
    path = os.path.join( work,
                         arch + '_' +
                         'redhat-' + str( redhat_version ) + '_' +
                         how + '_' +
                         'pip-' + str( ver ) )
    return path

def check_work( work ):
    "check working directory"
    global prompt_rm_all, ERROR

    if os.path.isfile( work ):
        err_msg( [ work, 'is not a directory but a file' ] )
        return False
    if not os.path.isdir( work ):
        return True
    if DRYRUN:
        return True
    if prompt_rm_all or ARGS.yes:
        if not delete_work_dir( work ):
            return False
        return True

    warn_msg( [ 'Work directory already exists:', work ] )
    while True:
        try:
            prompt = "Delete work directory before install? " \
                "'yes', 'all' or 'No' [y/a/n]: "
            choice = input( prompt ).lower()
        except:
            ERROR = True
            return False

        if choice == '':
            continue
        if choice[0] == 'y':
            break
        elif choice[0] == 'a':
            prompt_rm_all = True # never ask again
            break;
        if choice[0] == 'n':
            ERROR = True
            return False
        continue
    if not delete_work_dir( work ):
        return False
    return True

def create_work( work ):
    "make work directory"

    if DRYRUN:
        return work, None
    try:
        log_dir = os.path.join( work, 'log' )
        if not os.path.isdir( log_dir ):
            os.makedirs( log_dir )
        log_path = os.path.join( log_dir, 'pip-pip.log' )
    except Exception as e:
        err_msg( [ 'create_work:', e ] )
        return None, None
    return work, log_path

def check_file( file ):
    "check if the file exists or not"

    if DRYRUN:
        return True
    return os.path.isfile( file )

def do_poll( proc, t, dot, inc, tmax, log_fs ):
    "do poll and output dots"

    if t < 100:
        delta = 0.2
    elif t < 1000:
        delta = 1.0
    else:
        delta = 10.0

    td = 0.0
    while True:
        ret = proc.poll()
        if ret is not None or t >= tmax:
            if t < 60:
                tu = t
                unit = 's'
            elif t < 3600:
                tu = t / 60
                unit = 'm'
            else:
                tu = t / 3600
                unit = 'h'

            if ret is None:
                message( [ str(int(tu))+unit ], newline=False )
                return None, t
            message( [ ' '+str(int(tu))+unit ], newline=False )
            break
        if td >= inc:
            t += inc
            td = 0.0
            message( [ dot ], newline=False )

        time.sleep( delta )
        td += delta

    if ret != 0:
        message( [ ' - NG' ], log=log_fs )
        return False, t
    message( [ ' - OK' ], log=log_fs )
    return True, t

def execute( wd, cmd, log_fs ):
    "execute a Linux command"
    global ERROR

    if DRYRUN:
        message( [ '[DRY]' ] + cmd, log=log_fs )
        return True
    if ERROR:
        message( [ MSG_PREFIX ] +
                 cmd +
                 [ '-- execution skipped due to prev. error' ],
                 log=log_fs )
        return False

    try:
        message( [ MSG_PREFIX ] + cmd, newline=False, log=log_fs )
        message( [], newline=True, log=log_fs, logonly=True )
        if wd is not None:
            cmd_list = [ 'cd', wd, '&&' ] + cmd
        else:
            cmd_list = cmd
        shell_cmd = [ '/bin/sh', '-c', ' '.join( cmd_list ) ]
        proc = sp.Popen( shell_cmd, close_fds=True,
                         stdout=log_fs, stderr=log_fs )

        message( ' ', newline=False )
        inctab = [ ( '.',       1,       10 ),
                   ( '.',       6,       60 ),
                   ( '.',      60,      360 ),
                   ( '.',     360,     3600 ),
                   ( '.',    3600,  24*3600 ),
                   ( '.', 24*3600, 9999*999 ) ]
        t = 0
        for ( dot, inc, tmax ) in inctab:
            ( ret, t ) = do_poll( proc, t, dot, inc, tmax, log_fs )
            if ret is not None:
                time.sleep( 1 )     # wait for stdout/stderr flushing
                return ret
    except Exception as e:
        err_msg( [ '\nException:', e ], log=log_fs )
        return False

def install_yum( pip_ver, work_dir, log_fs ):
    "yum install"
    yum_pip = 'process-in-process-v' + str( pip_ver )
    message( [ MSG_ENTER, 'Yum install', yum_pip ], log=log_fs )
    retuple = ( 'yum', yum_pip, '' )
    if not execute( None,
                    sudo_cmd + [ 'yum', 'reinstall', '-y', yum_pip ],
                    log_fs ):
        return False, retuple

    if not ARGS.notest:
        repo_test  = concat_urls( git_url_tab['github'],
                                  git_repo_tab['github']['test']  )

        message( [ MSG_PREFIX1, 'Testing', repo_test ], log=log_fs )
        if not execute( work_dir, GIT_CLONE + [ repo_test ], log_fs ):
            return False, retuple
        test_dir = os.path.join( work_dir, 'PiP-Testsuite' )
        configure = os.path.join( test_dir, 'configure' )
        if not execute( test_dir,
                        [ configure, '--with-pip=/usr' ],
                        log_fs ):
            return False, retuple
        if not execute( test_dir, [ 'make', 'test' ], log_fs ):
            return False, retuple
    return True, retuple

def install_docker( pip_ver, log_fs ):
    "docker install"
    docker_pip = docker_img + str( pip_ver )
    message( [ MSG_ENTER, 'Docker install', docker_pip ], log=log_fs )
    retuple = ( 'docker', docker_pip, '' )
    if execute( None,
                sudo_cmd + [ 'docker', 'inspect', docker_pip ], log_fs ):
        if ARGS.noupdate:
            return True, retuple

        message( [ MSG_PREFIX1,
                   'Removing existing image', docker_pip ],
                 log=log_fs )
        if not execute( None,
                        sudo_cmd + [ 'docker', 'rmi', docker_pip ],
                        log_fs ):
            err_msg( [ 'Failed to remove existing image', docker_pip ],
                       log=log_fs )
            return False, retuple
    message( [ MSG_PREFIX1, 'Pulling existing image', docker_pip ], log=log_fs )
    if not execute( None, sudo_cmd + [ 'docker', 'pull', docker_pip ], log_fs ):
        return False, retuple
    return True, retuple

def install_spack( prefix, how, pip_ver, log_fs ):
    "Spack install"
    global spack_path
    spack_pip = 'process-in-process@' + str( pip_ver )
    retuple = ( 'spack', spack_pip, '' )
    if spack_path == '':        # Spack unable
        return False, retuple

    message( [ MSG_ENTER, 'Spack install', spack_pip ], log=log_fs )
    if spack_path is None:
        prefix_dir = create_prefix( prefix, how, pip_ver )
        if prefix_dir is None:
            return False, retuple
        if not ARGS.develop:
            url = spack_url
        else:
            url = spack_url_dev
        bsnam = os.path.splitext( os.path.basename( url ) )[0]
        spack_dir = os.path.join( prefix_dir, bsnam )
        if os.path.isdir( os.path.join( spack_dir, '.git' ) ):
            message( [ MSG_PREFIX1, 'Pulling Spack at', prefix_dir ], log=log_fs )
            if not execute( spack_dir, [ 'git', 'pull', url ], log_fs ):
                return False, retuple
        else:
            message( [ MSG_PREFIX1, 'Cloning Spack at', prefix_dir ], log=log_fs )
            if not execute( prefix_dir, GIT_CLONE + [ url ], log_fs ):
                spack_path = ''     # mark as not found
                return False, retuple
        spack_path = os.path.join( prefix_dir, bsnam, 'bin', 'spack' )

    retuple = ( 'spack', spack_pip, spack_path )
    if execute( None, [ spack_path, 'find', spack_pip ], log_fs ):
        if ARGS.noupdate:
            return True, retuple
        message( [ MSG_PREFIX1, 'Uninstalling', spack_pip ], log=log_fs )
        if not execute( None, [ spack_path, 'uninstall', '-y', spack_pip ], log_fs ):
            return False, retuple
    message( [ MSG_PREFIX1, 'Installing', spack_pip ], log=log_fs )
    if not execute( None, [ spack_path, 'install',  spack_pip ], log_fs ):
        return False, retuple
    return True, retuple

def wget_install( work_dir, prefix_dir, pkgname, url, log_fs ):
    "wget install for required package"
    if not execute( work_dir, [ 'wget', url ], log_fs ):
        err_msg( [ 'wget_install: wget', url, '-- FAILED' ], log=log_fs )
        raise Exception()
    [ mod_tar ] = re.findall( '.*/(.*)', url )
    if not check_file( os.path.join( work_dir, mod_tar ) ):
        err_msg( [ 'wget_install:', mod_tar, '-- unable to find' ], log=log_fs )
        raise Exception()
    if not execute( work_dir, [ 'tar', 'xzf', mod_tar ], log_fs ):
        err_msg( [ 'wget_install: tar xzf', mod_tar, '-- FAILED' ], log=log_fs )
        raise Exception()
    os.remove( os.path.join( work_dir, mod_tar ) )
    [ mod_name ] = re.findall( r'.*/(.*)\.tar.gz', url )
    mod_work = os.path.join( work_dir, mod_name )
    if not execute( mod_work,
                    [ './configure', '--prefix=' + prefix_dir ],
                    log_fs ):
        err_msg( [ 'wget_install: '
                   './configure', '--prefix='+prefix_dir,
                   '['+mod_name+'] -- FAILED' ],
                   log=log_fs )
        raise Exception()
    if not execute( mod_work, [ 'make' ], log_fs ):
        err_msg( [ 'wget_install: make ['+mod_name+'] -- FAILED' ],
                   log=log_fs )
        raise Exception()
    if not execute( mod_work, [ 'make', 'install' ], log_fs ):
        err_msg( [ 'wget_install: make install ['+mod_name+'] -- FAILED' ],
                   log=log_fs)
        raise Exception()
    return '--package=' + pkgname + ':' + prefix_dir

def install_git( prefix, repo, pip_ver, work_dir, log_fs  ):
    "Git (source) install"

    branch_pip = 'pip-' + str( pip_ver )

    retuple = ( 'git', repo + '@' + branch_pip, '' )
    if repo == 'github':
        git_repo = git_url_tab[repo]
        pip = 'PiP'
    elif repo == 'git-rccs':
        git_repo = git_url_tab[repo]
        pip = 'PIP'
    else:
        err_msg( [ 'Unknown git repo:', repo ], log=log_fs )
        return False, retuple

    message( [ MSG_ENTER, 'Git install', git_repo, 'PiP-v'+str( pip_ver ) ],
             log=log_fs )

    repo_glibc = concat_urls( git_repo, git_repo_tab[repo]['glibc'] )
    repo_pip   = concat_urls( git_repo, git_repo_tab[repo]['pip']   )
    repo_gdb   = concat_urls( git_repo, git_repo_tab[repo]['gdb']   )
    repo_test  = concat_urls( git_repo, git_repo_tab[repo]['test']  )
    git_pip = repo_pip + '@' + branch_pip
    retuple = ( 'git', git_pip, '' )
    if redhat_version == 7:
        ( branch_glibc, branch_gdb ) = gnu_branch_tab[7]
    elif redhat_version == 8:
        ( branch_glibc, branch_gdb ) = gnu_branch_tab[8]
    else:
        err_msg( [ 'Unsupported RedHat/CentOS version:',
                   str( redhat_version ) ],
                 log=log_fs )
        return False, retuple

    prefix_dir = create_prefix( prefix, repo, pip_ver )
    if prefix_dir is None:
        return False, retuple
    retuple = ( 'git', git_pip, prefix_dir )

    glibc_srcdir  = os.path.join( work_dir,     pip + '-glibc'  )
    build_script  = os.path.join( glibc_srcdir, 'build.sh'      )
    glibc_build   = os.path.join( work_dir,     'glibc_build'   )
    glibc_install = os.path.join( prefix_dir,   'glibc_install' )
    if ARGS.noglibc:
        message( [ MSG_PREFIX1, 'Skipping PiP-glibc build (--noglibc)' ],
                 log=log_fs )
    else:
        message( [ MSG_PREFIX1, 'Cloning', repo_glibc, branch_glibc ],
                 log=log_fs )
        if not execute( work_dir,
			GIT_CLONE + [ '-b', branch_glibc, repo_glibc ],
                        log_fs ):
            return False, retuple
        message( [ MSG_PREFIX1, 'Building', repo_glibc ], log=log_fs )
        if make_directory( glibc_build, True ) is None:
            return False, retuple
        if make_directory( glibc_install, True ) is None:
            return False, retuple
        if not execute( glibc_build, [ build_script, glibc_install ], log_fs ):
            return False, retuple
        piplnlibs = os.path.join( glibc_install, 'bin', 'piplnlibs.sh' )
        if not check_file( piplnlibs ):
            err_msg( [ 'Unable to find: ', piplnlibs ], log=log_fs )
            return False, retuple

    message( [ MSG_PREFIX1, 'Cloning', repo_pip, branch_pip ], log=log_fs )
    if not execute( work_dir,
                    GIT_CLONE + [ '-b', branch_pip, repo_pip ],
                    log_fs ):
        return False, retuple

    message( [ MSG_PREFIX1, 'Building', repo_pip ], log=log_fs )
    pip_dir = os.path.join( work_dir, pip )
    configure = os.path.join( pip_dir, 'configure' )
    if ARGS.noglibc:
        if not execute( pip_dir,
                        [ configure, '--prefix=' + prefix_dir ],
                        log_fs ):
            return False, retuple
    else:
        if not execute( pip_dir,
                        [ configure,
                          '--prefix=' + prefix_dir,
                          '--with-glibc-libdir=' + glibc_install + '/lib' ],
                        log_fs ):
            return False, retuple
    if not execute( pip_dir, [ 'make' ], log_fs ):
        return False, retuple
    if not execute( pip_dir, [ 'make install' ], log_fs ):
        return False, retuple
    if not execute( pip_dir, [ 'make', 'doc-install' ], log_fs ):
        return False, retuple

    if not ARGS.notest:
        message( [ MSG_PREFIX1, 'Testing', repo_pip ], log=log_fs )
        if not execute( work_dir, GIT_CLONE + [ repo_test ], log_fs ):
            return False, retuple
        test_dir = os.path.join( work_dir, pip + '-Testsuite' )
        configure = os.path.join( test_dir, 'configure' )
        if not execute( test_dir,
                        [ configure, '--with-pip=' + prefix_dir ],
                        log_fs ):
            return False, retuple
        if not execute( test_dir, [ 'make', 'test' ], log_fs ):
            return False, retuple

    if ARGS.noglibc or ARGS.nogdb:
        message( [ MSG_PREFIX1,
                   'Skipping PiP-gdb build (--noglibc or --nogdb)' ],
                 log=log_fs )
    else:
        message( [ MSG_PREFIX1, 'Cloning', repo_gdb, branch_gdb ],
                 log=log_fs )
        if not execute( work_dir,
                        GIT_CLONE + [ '-b', branch_gdb, repo_gdb ],
                        log_fs ):
            return False, retuple

        inst_pkgs = []
        if not DRYRUN:
            message( [ MSG_PREFIX1,
                       'Checking required packages', repo_gdb ],
                     log=log_fs )
            gdb_dir = os.path.join( work_dir, pip + '-gdb' )
            build_script = os.path.join( gdb_dir, 'build.sh' )
            try:
                psproc = sp.Popen( [ build_script, '--missing' ],
                                   stdout=sp.PIPE, stderr=NULL_FILE )
                while True:
                    mod = psproc.stdout.readline()
                    if mod == '':
                        break
                    missing = mod.split()
                    if missing == []:
                        break
                    [ pkgname, url ] = missing
                    installed = wget_install( work_dir,
                                              prefix_dir,
                                              pkgname,
                                              url,
                                              log_fs )
                    if not installed in inst_pkgs:
                        inst_pkgs += [ installed ]
            except Exception as e:
                err_msg( [ build_script+' --missing: FAILED', e ],
                         log=log_fs )
                return False, retuple

        message( [ MSG_PREFIX1, 'Building', repo_gdb ], log=log_fs )
        gdb_dir = os.path.join( work_dir, pip + '-gdb' )
        build_script = os.path.join( gdb_dir, 'build.sh' )
        if not execute( gdb_dir,
                        [ build_script,
                          '--prefix='   + prefix_dir,
                          '--with-pip=' + prefix_dir ] + inst_pkgs,
                        log_fs ):
            return False, retuple
        pip_gdb = os.path.join( prefix_dir, 'bin', 'pip-gdb' )
        if not check_file( pip_gdb ):
            err_msg( [ 'Unable to find: ', pip_gdb ], log=log_fs )
            return False, retuple
    if not ARGS.keep:
        delete_work_dir( work_dir )
    return True, retuple

if ERROR:
    NULL_FILE.close()
    sys.exit( 1 )

prefix = ARGS.prefix
if len(prefix) > 2 and prefix[-2:] == '//':
    FLAG_SUBDIR = True
    prefix = prefix[0:-2]
prefix_dir = check_prefix( prefix )
work_dir   = os.path.realpath( os.path.expanduser( ARGS.work ) )

# check work and prefix dirs if work can be deleted
common = os.path.commonprefix( [ work_dir, prefix_dir ] )
if common is work_dir:          # this means work_dir is upper of prefix_dir
    if not ARGS.keep:
        if not DRYRUN:
            err_msg( [ 'Work dir includes prefix dir and ' +
                       'work dir cannot be deleted.' ] )
        else:
            warn_msg( [ 'Work dir includes prefix dir and ' +
                        'work dir cannot be deleted.' ] )

if ERROR:
    NULL_FILE.close()
    sys.exit( 1 )

### NOW we can actually do the installation(s)

def is_ready( how, arch, redhat_version, pip_ver ):
    if DRYRUN:
        return True
    (deploy, develop) = ready[how,str(arch),redhat_version,pip_ver]
    if not ARGS.develop:
        return deploy
    return develop

# check work dir, delete if exists
for how in how_list:
    for ver in pip_vers:
        if is_ready( how, arch, redhat_version, ver ):
            check_work( work_path( work_dir, how, ver ) )
if ERROR:
    NULL_FILE.close()
    sys.exit( 1 )

ready_list     = []
not_ready_list = []
message( [] )
message( [ 'Redhat/Centos:\t\t', redhat_version ] )
message( [ 'CPU Architecture:\t', arch ])
message( [] )
message( [ 'List of installations' ] )
for ver in pip_vers:
    for how in how_list:
        if not is_ready( how, arch, redhat_version, ver ) :
            not_ready_list.append( ( how, ver ) )
        else:
            ready_list.append( ( how, ver ) )
            message( [ how.upper(), '\tPiP-v' + str( ver ) ] )
            if how == 'spack' and spack_path != 'spack':
                message( [ '  Prefix dir:\t',
                           prefix_path( prefix_dir, how, ver ) ] )
            elif how == 'github':
                message( [ '  Prefix dir:\t',
                           prefix_path( prefix_dir, how, ver ) ] )
                message( [ '  Work dir:\t',
                           work_path( work_dir, how, ver ) ] )
            elif how == 'git-rccs':
                message( [ '  Prefix dir:\t',
                           prefix_path( prefix_dir, how, ver ) ] )
                message( [ '  Work dir:\t',
                           work_path( work_dir, how, ver ) ] )
if not_ready_list != []:
    message( [] )
    if len( not_ready_list ) == 1:
        warn_msg( [ 'The following is not ready and',
                    'installtion will be skipped' ] )
    else:
        warn_msg( [ 'The followings are not ready and',
                    'installtion will be skipped' ] )

    for ( how, ver ) in not_ready_list:
        message( [ '\t'+how.upper()+': PiP-v' + str( ver ) ] )

## let's start installation(s)

ERROR = False

list_success = []
list_failure = []
list_skipped = []

for ( how, pip_ver ) in ready_list:
    ERROR = False
    message( [] )
    if not is_ready( how, arch, redhat_version, pip_ver ):
        list_skipped.append( ( how, arch, redhat_version, pip_ver ) )
        continue

    ( wdir, log_path ) = create_work( work_path( work_dir, how, pip_ver ) )
    if wdir is None:
        NULL_FILE.close()
        sys.exit( 1 )

    try:
        log_fs = None
        if not DRYRUN:
            log_fs = open( log_path, mode='w' )

        now_str = datetime.datetime.now().strftime( '%Y-%m-%d %H:%M:%S' )
        message( [ now_str, SEP ], log=log_fs, logonly=True )

        if how == 'yum':
            retuple = install_yum(    pip_ver, wdir, log_fs )
        elif how == 'docker':
            retuple = install_docker( pip_ver, log_fs )
        elif how == 'spack':
            retuple = install_spack( prefix_dir, how, pip_ver, log_fs )
        elif how == 'github':
            retuple = install_git( prefix_dir,   how, pip_ver, wdir, log_fs )
        elif how == 'git-rccs':
            retuple = install_git( prefix_dir,   how, pip_ver, wdir, log_fs )

        ( ok, ( how, obj, note ) ) = retuple
        if ok:
            list_success.append( ( how, obj, note ) )
            message( [ MSG_EXIT,  how, 'install', obj, 'OK' ], log=log_fs )
        else:
            list_failure.append( ( how, obj, log_path ) )
            err_msg( [ how, 'install', obj, 'NG' ], log=log_fs )

        now_str = datetime.datetime.now().strftime( '%Y-%m-%d %H:%M:%S' )
        message( [ SEP, now_str ], log=log_fs, logonly=True )
        if log_fs is not None:
            log_fs.close()

    except Exception as e:
        err_msg( [ e ] )
        message( [ '**** logfile:', log_path ] )
    except KeyboardInterrupt:
        message( [ '\n^C' ] )
        NULL_FILE.close()
        sys.exit( 1 )

if list_success == [] and list_failure == []:
    # this should not happen
    NULL_FILE.close()
    sys.exit( 1 )

if not ARGS.keep:
    message( [] )
    if list_failure == []:
        delete_work_dir( wdir )
    else:
        message( [ 'the work dir is not deleted due to the error' ] )

## Summary

yum_success    = False
docker_success = False
message( [ '\nSummary' ] )
if list_success != []:
    for ( how, obj, note ) in list_success:
        if not DRYRUN:
            message( [ 'OK\t' ], newline=False )
        else:
            message( [ '[DRY]\t' ], newline=False )
        if note == '':
            message( [ how, obj ] )
        else:
            message( [ how, obj, note ] )

        if how == 'yum':
            yum_success = True
        elif how == 'docker':
            docker_success = True

if list_skipped != []:
    for ( how, arch, redhat, pip_ver ) in list_skipped:
        message( [ 'SKIPPED\t',
                   how,
                   arch,
                   'redhat'+str(redhat),
                   'PiP-v'+str(pip_ver) ] )

if list_failure != []:
    for ( how, obj, log_path ) in list_failure:
        message( [ 'NG\t' ], newline=False )
        if log_path == '':
            message( [ how, obj ] )
        else:
            message( [ how, obj, ' **LOG:', log_path ] )

if yum_success or docker_success:
    message( [ '\nNote' ] )

if yum_success:
    message( [ 'YUM: PiP package is installed at /usr' ] )

if docker_success:
    message( [ 'DOCKER: To run the PiP Docker image:' ] )
    message( [ '\t$ [sudo] docker run -it rikenpip/pip-v<PIP_VERSION> /bin/bash' ] )

NULL_FILE.close()
if list_failure != []:
    sys.exit( 1 )

sys.exit( 0 )
